# MIT License

# Copyright (c) 2024 bright-rookie

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# ## DISCLAIMER

# The information provided by aisafe_back (owned by GitHub user bright-rookie) 
# on this GitHub repository or on the website `aisafe.qbio.page` is for 
# educational and informational purposes only. 
# All code and data within this repository are mock data and examples intended 
# solely for demonstration and experimentation with machine learning models. 
# This repository does not contain functional AI models or real medical data, 
# and any outputs generated by the code are purely fictional and lack any basis
#  in real-world medical analysis or diagnostics.

# UNDER NO CIRCUMSTANCES should any code, data, or outputs from this repository 
# be used in clinical settings, to make medical decisions, or as a substitute 
# for professional healthcare advice. bright-rookie and contributors to this 
# repository disclaim any liability for damages resulting from the use or misuse
#  of information contained within this repository. 
# Use of this repository and reliance on any content are entirely at your own risk.

# This repository may contain links to other websites or use external content and packages 
# maintained by third parties. These links and external packages are used for convenience only, 
# and bright-rookie and contributors do not endorse, guarantee, or take responsibility 
# for the accuracy or completeness of any information available through these links or packages.
# We have not investigated or verified the content of linked websites or external packages,
# Use of such external resources is also entirely at your own risk.

# ### Professional Disclaimer

# This repository does not provide real medical or health advice. 
# The code and data are intended solely for instructional purposes in machine learning and 
# should not be used for any medical or diagnostic purposes. The repository does not and 
# cannot provide any kind of medical advice or treatment recommendation. 
# For any medical concerns, consult a qualified healthcare professional.

import pandas as pd
import xgboost as xgb
import numpy as np
from pathlib import Path
from aisafe_xgboost.utils import MockData

PACKAGEDIR = Path(__file__).parent.absolute()
MODELDIR = PACKAGEDIR / 'models'

def model(**kwargs):
    # load data
    mockdata = MockData()
    expected_cols = mockdata.expected_columns
    dfs = [pd.DataFrame([list(arg)], columns = expected_cols[type]) for type, arg in kwargs.items()]
    dmtx = [xgb.DMatrix(df) for df in dfs]
    models = [xgb.Booster(model_file= MODELDIR / f"model_{name}.ubj") for name in kwargs.keys()]
    weights = np.load(MODELDIR / "optimal_weights.npy")
    predicted = np.array([model.predict(dmatrix) for model, dmatrix in zip(models, dmtx)]).squeeze()
    final_pred = np.sum(weights * predicted)
    final_pred_sub = weights * predicted
    final_pred_sub_rounded = np.round(final_pred_sub, 3)

    prediction_names = ['신체 계측치', '멍 정보', '문진 정보', 'Lab 수치', 'X-ray 영상', '진료 영상']
    sorted_indices = np.argsort(final_pred_sub)[::-1]
    sorted_weights = np.array(final_pred_sub_rounded)[sorted_indices]
    sorted_names = np.array(prediction_names)[sorted_indices]

    explainability = list(zip(sorted_names, sorted_weights))

    return final_pred, explainability

if __name__ == "__main__":
    output=model(
        info=(120,0,11.67,13.84),
        bruise=[0 for _ in range(11)],
        response=[0 for _ in range(9)],
        lab=[0 for _ in range(19)],
        xray=[0 for _ in range(9)],
        video=[0 for _ in range(30)],
    )
    print(f"Final prediction: {output}")
